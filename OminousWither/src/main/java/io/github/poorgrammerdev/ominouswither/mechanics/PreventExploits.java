package io.github.poorgrammerdev.ominouswither.mechanics;

import java.util.HashSet;
import java.util.UUID;

import org.bukkit.Location;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.SoundCategory;
import org.bukkit.World;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Wither;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.entity.EntityDamageEvent.DamageCause;
import org.bukkit.util.Vector;

import io.github.poorgrammerdev.ominouswither.OminousWither;
import io.github.poorgrammerdev.ominouswither.coroutines.PassableLocationFinder;
import io.github.poorgrammerdev.ominouswither.internal.CoroutineManager;

/**
 * Prevents trivializing the Ominous Wither fight by exploiting game mechanics
 * (e.g. trapping it in bedrock or some other unbreakable block)
 * @author Thomas Tran
 */
public class PreventExploits implements Listener {
    private final OminousWither plugin;
    private final HashSet<UUID> activeSearches;
    
    public PreventExploits(OminousWither plugin) {
        this.plugin = plugin;
        this.activeSearches = new HashSet<>();
    }

    /**
     * If the Wither suffocates for any reason, it will teleport to a safe location
     */
    @EventHandler(ignoreCancelled = true)
    private void onSuffocate(final EntityDamageEvent event) {
        //Must be suffocation damage
        if (event.getCause() != DamageCause.SUFFOCATION) return;

        //Entity must be an ominous wither
        if (event.getEntityType() != EntityType.WITHER || !(event.getEntity() instanceof Wither)) return;

        final Wither wither = (Wither) event.getEntity();
        if (!this.plugin.isOminous(wither)) return;

        //Ominous Wither cannot suffocate
        event.setCancelled(true);

        //An active search cannot already be taking place
        final UUID witherID = wither.getUniqueId();
        if (this.activeSearches.contains(witherID)) return;

        //Find a suitable location to teleport to
        this.activeSearches.add(witherID);
        CoroutineManager.getInstance().enqueue(new PassableLocationFinder(
            wither.getLocation(),
            new Vector(10, 10, 10),
            4,
            false,
            false,
            1,
            (location) -> {
                final Entity entity = plugin.getServer().getEntity(witherID);
                if (entity == null) return;

                final Location sourceLocationFX = entity.getLocation().add(0, 1, 0);

                //Teleport wither to safe location
                entity.teleport(location);

                final World world = entity.getWorld();
                if (world == null) return;

                //Play visual and audio effects for teleport
                final Location locationFX = location.add(0, 1, 0);

                world.spawnParticle(Particle.WITCH, locationFX, 250, 0.5, 1.5, 0.5);

                world.spawnParticle(Particle.FLASH, sourceLocationFX, 1);
                world.spawnParticle(Particle.FLASH, locationFX, 1);

                world.playSound(entity, Sound.ENTITY_PLAYER_TELEPORT, SoundCategory.HOSTILE, 5, 1);            
            },
            (amount) -> {
                this.activeSearches.remove(witherID);
            }
        ));
    }
}
